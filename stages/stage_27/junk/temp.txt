//if paging is happening
if( [SYSTEM_STATUS_TABLE + 5] != 0 ) then
print "paging happe";
	if( [PROCESS_TABLE + 15*16 + 4] == WAIT_DISK ) then
		[SYSTEM_STATUS_TABLE + 1] = 0; //idle
		[PROCESS_TABLE + 0*16 + 4] = RUNNING;
		PTBR = [PROCESS_TABLE + 0*16 + 14];
		PTLR = [PROCESS_TABLE + 0*16 + 15];
		SP = [PROCESS_TABLE + 0*16 + 11]*512 + [PROCESS_TABLE + 0*16 + 12];
		multipop(BP);
		return;

	else
		[SYSTEM_STATUS_TABLE + 1] = 15; //swap daemon is scheduled
		
		PTBR = [PROCESS_TABLE + 15*16 + 14];
		PTLR = [PROCESS_TABLE + 15*16 + 15];
		
		if ([PROCESS_TABLE + 15*16 + 4] == CREATED) then 
			print "swapper daemon scheduled";
			[PROCESS_TABLE + 15*16 + 4] = RUNNING;
			SP=[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13];
			ireturn;
		else
			[PROCESS_TABLE + 15*16 + 4] = RUNNING;
			SP = [PROCESS_TABLE + 15*16 + 11]*512 + [PROCESS_TABLE + 15*16 + 12];
			multipop(BP);
			return;
		endif;
		
		
	endif;
endif;
//print "On the right track";
//------------------------------------------------------------------------------------
print [SYSTEM_STATUS_TABLE + 1];
//stage 27

if( [SYSTEM_STATUS_TABLE+5] == SWAP_IN || [SYSTEM_STATUS_TABLE+5] == SWAP_OUT ) then
	print "actualswap";
	if( [SYSTEM_STATUS_TABLE+1] == 15 && [SYSTEM_STATUS_TABLE+5] == SWAP_IN ) then
		//call swap_in() fun from Pager module
		R1 = SWAP_IN;
		print "swapping in";
		call MOD_6;
	else 
		if( [SYSTEM_STATUS_TABLE+1] == 15 && [SYSTEM_STATUS_TABLE+5] == SWAP_OUT ) then
			//call swap_out() fun from Pager module
			print "swapping out";
			R1 = SWAP_OUT;
			call MOD_6;
		endif;
	endif;

else
	if ( [SYSTEM_STATUS_TABLE+2] < MEM_LOW ) then
		//set paging status in system status table
		[SYSTEM_STATUS_TABLE+5] = SWAP_OUT;
	
	else
		if( [SYSTEM_STATUS_TABLE+4] > 0 ) then
			R0 = 3;
			while (R0 < MAX_PROC_NUM - 1) do
				if( [PROCESS_TABLE+R0*16+6] == 1 && [PROCESS_TABLE+R0*16] > MAX_TICK ) then
					[SYSTEM_STATUS_TABLE + 5] = SWAP_IN;
					break;
				endif;
				R0 = R0 + 1;
			endwhile;
			if (R0 == MAX_PROC_NUM - 1) then
				if ([SYSTEM_STATUS_TABLE+2] > MEM_HIGH) then
					[SYSTEM_STATUS_TABLE + 5] = SWAP_IN;
				endif;
			endif;
		endif;
	endif;
endif;

//over stage 27

//--------------------------------------------------------------------
//for each stack page store it
	i = 8;
	while( i < 10 ) do
		//call get swap block from memory manager
		multipush(R1,R2,R3);
		R1 = GET_SWAP_BLOCK;
		call MOD_2;
		multipop(R1,R2,R3);
		
		//storing the stack page to disk
		multipush(R0,R1,R2,R3);
		R1 = DISK_STORE;
		R2 = swap_pid;
		R3 = [PAGE_TABLE_BASE + swap_pid*20 + i*2];
		R4 = R0;
		call MOD_4;
		multipop(R0,R1,R2,R3);
		
		//call release page from memory manager
		multipush(R0,R1,R2,R3);
		R1 = RELEASE_PAGE;
		R2 = [PAGE_TABLE_BASE + swap_pid*20 + i*2];
		call MOD_2;
		multipop(R0,R1,R2,R3);
		
		//updating the disk map table entry of process to store disk block number allocated to stack page
		[DISK_MAP_TABLE + swap_pid*10 + i] = R0;
		
		//invalidating page table of stack page
		[PAGE_TABLE_BASE + 20*swap_pid + i*2] = -1;
		[PAGE_TABLE_BASE + 20*swap_pid + i*2 + 1] = "0000";
		
		i = i + 1;
	endwhile;

	//for each stack page load it
	i = 8;
	while( i < 10 ) do
		//call get free page from memory manager
		backup;
		R1 = GET_FREE_PAGE;
		call MOD_2;
		[PAGE_TABLE_BASE + max*20 + i*2] = R0;
		restore;

		alias diskBlock R5;
		diskBlock = [DISK_MAP_TABLE + 10*max + 2];

		//do the disk load fun of device manager module
		backup;
		R1 = DISK_LOAD;
		R2 = max;
		R3 = [PAGE_TABLE_BASE + max*20 + i*2];
		R4 = diskBlock;
		call MOD_4;
		restore;

		//release the block that had the swaped out heap page
		//release_block() fun of memory manager module
		backup;
		R1 = RELEASE_BLOCK;
		R2 = diskBlock;
		R3 = max;
		call MOD_2;
		restore;

		[PAGE_TABLE_BASE + 20*max + i*2 + 1] = "0110";
		[DISK_MAP_TABLE + max*10 + i] = -1;
		i = i + 1;
	endwhile;
